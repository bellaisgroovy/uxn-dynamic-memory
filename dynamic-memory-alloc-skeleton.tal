( This is the suggested code skeleton for AE1
  it also provides helper functions for printing

  Replace `!todo` with your implementation for each function, 
  based on the Python reference

)

(
 Dynamic memory allocation using pages and a bitmap
)

|0000
( zero page, used for temporary storage )

|0100
(
Run your integration tests here
)
BRK

( define your integration tests here )

( definitions of malloc, free and functions used to implement them )
@malloc ( n_bytes -- <allocation in bytes> )
!todo

@free ( ptr n_bytes )
    SWP2 #f000 SUB2 PAGE_SZ DIV2
    ;free_alloc_sz_at_idx JMP2

@get_bit ( idx -- bit ) ( wait can i just do ;bitmap ADD2 LDA?? )
    ( get idx % 8 )
    DUP2 DUP2 ( idx, idx, idx )
    #03 SFT2 #30 SFT2 ( idx, idx, idx rounded to the nearest 8 )
    SUB2 ( idx, idx%8 )

    ( take away index of the bit from 7 )
    #0007 SWP2 SUB2 ( idx, bit_idx )
    SWP2 ( bit_idx, idx )

    ( if index is too big exit )
    #03 SFT2 ( bit_idx, byte_idx )
    N_PAGES #0001 SUB2 ( bit_idx, byte_idx, n_pages-1 )
    GTH2k ( bit_idx, byte_idx, n_pages-1, byte_idx>n_pages-1 )
    ,&invalid JCN POP2 ( bit_idx, byte_idx )

    ( get bitmap[byte_idx] )
    ;bitmap ADD2 LDA ( bit_idx, *bitmap[byte_idx] )

    ( get value of bit at idx finally )
    ( bit_idx, byte )
    ROT ( bit_idx_low, byte, bit_idx_high )
    POP ( bit_idx_low, byte )
    SWP ( byte, bit_idx_low )
    SFT ( byte>>bit_idx )
    #01 AND ( bit )
    JMP2r
    
    &invalid
        { 0016 "Outside 20 "of 20 "page 20 "range 0a } STH2r print-str
        BRK


@set_bit ( idx -- )
    ( byte_idx = idx >> 3 )
    DUP2 ( idx, idx )
    #03 SFT2 ( idx, byte_idx )

    ( bit_idx = 7 - {idx - {byte_idx<<3}} )
    DUP2 ( idx, byte_idx, byte_idx )
    #30 SFT ( idx, byte_idx, byte_idx>><<3 )
    ROT2 ( byte_idx, byte_idx>><<3, idx )
    ADD2 ( byte_idx, idx+byte_idx>><<3 )
    #0007 SWP2 ( byte_idx, 0070, idx+byte_idx>><<3 )
    SUB2 ( byte_idx, bit_idx )

    ( byte = bitmap[byte_idx] )
    SWP2 ( bit_idx, byte_idx )
    ;bitmap ( bit_idx, byte_idx, &bitmap )
    ADD2 ( bit_idx, &bitmap[byte_idx] )
    
    ( bitmap[byte_idx] = byte | mask_set{bit_idx} )
    DUP2 ROT2 SWP2 (  &bitmap[byte_idx], bit_idx, &bitmap[byte_idx] )
    LDA (  &bitmap[byte_idx], bit_idx, *bitmap[byte_idx] )
    ROT ROT ( &bitmap[byte_idx], *bitmap[byte_idx], bit_idx )
    mask_set ( &bitmap[byte_idx], *bitmap[byte_idx], mask )
    ORA ( &bitmap[byte_idx], byteMasked )
    ROT ROT ( byteMasked, &bitmap[byte_idx] )
    STA ( -- )
    JMP2r

@mask_set ( idx16 ) ( returns mask with bit idx spaces left as 1 and the rest 0 )
    SWP POP ( makes idx byte instead of short ) ( idx8 ) ( is this def right? )
    #40 SFT ( moves low nibble of idx to high nibble ) ( idx8<<4 )
    #01 SWP SFT ( moves 1 in 0000 0001 left by value of idx ) ( 1<<idx8<<4 )
    JMP2r

@clear_bit ( idx -- )
!todo

@mask_clear
!todo

( allocation size is in pages )
@alloc_sz_is_free_at_idx ( idx alloc_sz -- 00 or 01 )

    ( if out of range return 0 )
    ADD2k N_PAGES #0001 SUB2 ( idx, alloc_sz, idx+alloc_sz, N_PAGES-1 )
    GTH2 ( idx, alloc_sz, result ) 
    ,&out-of-range JCN ( idx, alloc_sz )

    ( if any bits in the alloc range are taken return 0 )
    #0000 ( idx, alloc_sz, counter )
    &loop
        LTH2k ,&free JCN ( if alloc_sz < counter finish loop  )

        ( if bit at idx+counter is allocated return 0 )
        ROT2 ( alloc_sz, counter, idx )
        ADD2k (alloc_sz, counter, idx, counter+idx )
        get_bit #01 EQU (alloc_sz, counter, idx, bit==1 )
        ,&not-free JCN ( alloc_sz, counter, idx )

        ( prepare for next iteration )
        ROT2 ( counter, idx, alloc_sz )
        ROT2 ( idx, alloc_sz, counter )
        INC2
        ,&loop JMP

    &out-of-range
        POP2 POP2 ( clear stack )
        #00 JMP2r ( return 0 )

    &not-free
        POP2 POP2 POP2
        #00 JMP2r

    &free
        POP2 POP2 POP2 ( clear stack )
        #01 JMP2r

    

@claim_alloc_sz_at_idx ( idx alloc_sz ) 
!todo

@free_alloc_sz_at_idx ( idx alloc_sz ) 
!todo

( ==================================================== )
( Functions for printing )
@todo { 0005 "TODO 0a } STH2r print-str JMP2r

@print-bit #30 ADD #18 DEO JMP2r
@nl #0a18 DEO JMP2r ( print new line )
@ws #2018 DEO JMP2r ( print white space )

@print8 ( b -: )
    ( DUP ) ( b b )
    DUP ( b b b )
    lonib ( b b ln )
    h2a ( b b lna )
    SWP ( b lna b )
    hinib ( b lna hn )
    h2a ( b lna hna )
    #18 DEO #18 DEO ( POP )
    JMP2r

@print16 ( a* -: )
    SWP
    print8
    print8
    JMP2r

@lonib ( a -: b )
    #0f AND
    JMP2r

@hinib ( a -: b )
    #04 SFT
    JMP2r

@h2a ( a -: b )
    DUP ( a a )
    #0a LTH ( a c1 )
    DUP ( a c1 c1 )
    #01 SWP SUB ( a c1 1-c1 )
    #57 MUL ( a c1 [1-c1]*57 )
    SWP ( a [1-c1]*57 c1 )
    #30 MUL ( a [1-c1]*57 c1*30 )
    ADD 
    ADD ( a+[1-c1]*57+c1*30 )
    JMP2r

( To print a 1-byte unsigned integer 
as a decimal number of 3 digits )
( a -: )
@print8-dec
    ( h = x/100 )
    DUP ( x x ) 
    DUP #64  LTH ,&d2 JCN 
    #64 DIV ( x h ) DUP #30 ADD #18 DEO ( x h )
    ( d = x - 100*h )
    #64 MUL SUB ( d )
    ( t = d / 10 )
    DUP ( d d )
    &d2
    DUP #0a  LTH ,&d3 JCN
    #0a DIV ( d t ) DUP #30 ADD #18 DEO ( d t )
    ( e = d - 10*t )
    #0a MUL SUB ( e ) 
    DUP ( e e )
    &d3
    #30 ADD #18 DEO
    POP
JMP2r
( To print a 2-byte unsigned integer 
as a decimal number of 5 digits )
( x:16 -> -- )
( x* -: )
@print16-dec
    DUP2 ( x:16 x:16 )
    DUP2 #2710 LTH2 ,&d2 JCN
    ( T = x/10000 )
    #2710 DIV2 ( x:16 T:16 ) DUP #30 ADD #18 DEO
    ( Dt = x - 10000*T )
    #2710 MUL2 SUB2 ( Dt )
    DUP2 ( Dt Dt )
    &d2
    DUP2 #03e8  LTH2 ,&d3 JCN
    ( D = Dt / 1000 )
    #03e8 DIV2 ( Dt D ) DUP #30 ADD #18 DEO
    ( ht = Dt-D*1000 )
    #03e8 MUL2 SUB2  ( ht )
    DUP2 ( ht ht )
    &d3
    DUP2 #0064  LTH2 ,&d4 JCN
    ( h = ht /100 )
    #0064 DIV2 ( ht h ) DUP #30 ADD #18 DEO
    ( tt = ht - h*100 )
    #0064 MUL2 SUB2 ( tt )
    DUP2 ( tt tt )
    &d4
    ( t = tt / 10 )
    #000a DIV2 ( tt t ) DUP #30 ADD #18 DEO
    ( e = tt - 10*t )
    #000a MUL2 SUB2 ( e ) #30 ADD #18 DEO POP
JMP2r

( To print a string )
( The string starts with a 2-byte lenght field )
@print-str ( a* -: )
    LDA2k ( ;str size )
    SWP2 #0002 ADD2 SWP2 ( ;str+2 size )
    DUP2 ( ;str+2 size size )
    ( So we test if that is 0 and if not we keep going )
    &loop
    #0000 EQU2 ,&exit JCN ( ;str+2 size )
    SWP2 ( size ;str+2 )
    LDAk #18 DEO ( size ;str+2 )
    INC2 SWP2 #0001 SUB2 DUP2 ( ;str+3 size-1 size-1 )
    ,&loop JMP
    &exit
    POP2 POP2 POP2
JMP2r

( example strings )
@invalid-str 000f "Invalid 20 "access:
@outside-str 0016 "Outside 20 "of 20 "page 20 "range:

( END of functions for printing and strings )
( ==================================================== )

@PAGE_SZ ( -: a* ) #0010 JMP2r ( We allocate 16 bytes per page )
@N_PAGES ( -: a* ) #0100 JMP2r ( We have a total of 256 pages, so we can allocate at most 4kB )
@DMEM_START ( -: a* ) #f000 JMP2r ( Start at 60*1024 )

( N_PAGES bits, packed in bytes mean N_PAGES/8 entries, so with the above, the bitmap will take 64 bytes )
( 0 means free )
@bitmap $40

( The dynamic allocation happens below this )
|f000
@dmem

